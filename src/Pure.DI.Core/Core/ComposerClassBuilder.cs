namespace Pure.DI.Core;

internal class ComposerClassBuilder : IBuilder<DependencyGraph, string>
{
    private const string MethodImplOptions = "[System.Runtime.CompilerServices.MethodImpl((System.Runtime.CompilerServices.MethodImplOptions)0x300)]";
    private const string DisposableTypeName = "System.IDisposable";
    private readonly IBuilder<DependencyGraph, IReadOnlyDictionary<Injection, Root>> _rootsBuilder;
    private readonly IBuilder<DependencyGraph, Resolvers> _resolverBuilder;

    public ComposerClassBuilder(
        IBuilder<DependencyGraph, IReadOnlyDictionary<Injection, Root>> rootsBuilder,
        IBuilder<DependencyGraph, Resolvers> resolverBuilder)
    {
        _rootsBuilder = rootsBuilder;
        _resolverBuilder = resolverBuilder;
    }

    public string Build(DependencyGraph dependencyGraph, CancellationToken cancellationToken)
    {
        var roots = _rootsBuilder.Build(dependencyGraph, cancellationToken);
        var resolvers = _resolverBuilder.Build(dependencyGraph with { Roots = roots }, cancellationToken);
        if (!resolvers.Lines.Any())
        {
            return string.Empty;
        }

        var argsFields = resolvers.ClassFields
            .Where(i => i.Key.Arg is { })
            .OrderBy(i => i.Key.Binding.Id)
            .ToImmutableArray();

        var singletonFields = resolvers.ClassFields
            .Where(i => Equals(i.Key.Binding.Lifetime?.Lifetime, Lifetime.Singleton))
            .OrderBy(i => i.Key.Binding.Id)
            .ToImmutableArray();

        var composerTypeNameParts = dependencyGraph.Source.ComposerTypeName.Split('.', StringSplitOptions.RemoveEmptyEntries);
        var className = composerTypeNameParts.Last();
        var ns = string.Join('.', composerTypeNameParts.Take(composerTypeNameParts.Length - 1));
        if (string.IsNullOrWhiteSpace(ns))
        {
            ns = dependencyGraph.Source.Namespace;
        }

        var usingDirectives = dependencyGraph.Source.UsingDirectives.ToHashSet();
        usingDirectives.Remove(ns);
        var code = new LinesBuilder();
        code.AppendLine("// <auto-generated/>");
        if (usingDirectives.Any())
        {
            foreach (var usingDirective in usingDirectives.OrderBy(i => i))
            {
                code.AppendLine($"using {usingDirective};");
            }

            code.AppendLine();
        }

        var nsIndent = Disposables.Empty;
        if (!string.IsNullOrWhiteSpace(ns))
        {
            code.AppendLine($"namespace {ns}");
            code.AppendLine("{");
            nsIndent = code.Indent();
        }

        code.AppendLine("[System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]");
        code.AppendLine($"partial class {className}{(singletonFields.Any() ? $": {DisposableTypeName}" : "")}");
        code.AppendLine("{");

        using (code.Indent())
        {
            var membersCounter = 0;
            if (resolvers.DisposablesCount > 0)
            {
                // DisposeIndex field
                code.AppendLine($"private int {Variable.DisposeIndexFieldName};");
                membersCounter++;
            }

            if (singletonFields.Any())
            {
                // Disposables field
                code.AppendLine($"private {DisposableTypeName}[] {Variable.DisposablesFieldName} = new {DisposableTypeName}[{resolvers.DisposablesCount}];");
                membersCounter++;

                // Singleton fields
                foreach (var classField in singletonFields)
                {
                    code.AppendLine($"private {classField.Key.Type} {classField.Value};");
                    membersCounter++;

                    if (classField.Key.Type.IsValueType)
                    {
                        code.AppendLine($"private bool {classField.Value}Created;");
                        membersCounter++;
                    }
                }
            }

            if (argsFields.Any())
            {
                foreach (var arg in argsFields)
                {
                    code.AppendLine($"private {arg.Key.Type} {arg.Value};");
                    membersCounter++;
                }

                code.AppendLine();

                // Constructor
                code.AppendLine($"public {className}({string.Join(", ", argsFields.Select(i => $"{i.Key.Type} {i.Key.Arg?.Source.ArgName}"))})");
                code.AppendLine("{");
                using (code.Indent())
                {
                    foreach (var arg in argsFields)
                    {
                        if (arg.Key.Type.IsValueType)
                        {
                            continue;
                        }

                        code.AppendLine($"if (System.Object.ReferenceEquals({arg.Key.Arg?.Source.ArgName}, null))");
                        code.AppendLine("{");
                        using (code.Indent())
                        {
                            code.AppendLine($"throw new System.ArgumentNullException(\"{arg.Key.Arg?.Source.ArgName}\");");
                        }

                        code.AppendLine("}");
                        code.AppendLine();
                    }

                    foreach (var arg in argsFields)
                    {
                        code.AppendLine($"{arg.Value} = {arg.Key.Arg?.Source.ArgName};");
                    }
                }

                code.AppendLine("}");
                membersCounter++;
            }

            // Roots
            foreach (var (root, lines) in resolvers.Lines.OrderByDescending(i => i.Key.IsPublic).ThenBy(i => i.Key.PropertyName))
            {
                if (membersCounter > 0)
                {
                    code.AppendLine();
                }

                code.AppendLines(BuildProperty(root.Injection.Type, root, lines));
                membersCounter++;
            }

            // Dispose()
            if (singletonFields.Any())
            {
                code.AppendLine();
                code.AppendLine("public void Dispose()");
                code.AppendLine("{");
                using (code.Indent())
                {
                    code.AppendLine($"lock ({Variable.DisposablesFieldName})");
                    code.AppendLine("{");
                    using (code.Indent())
                    {
                        if (resolvers.DisposablesCount > 0)
                        {
                            code.AppendLine($"while ({Variable.DisposeIndexFieldName}-- >= 0)");
                            code.AppendLine("{");
                            using (code.Indent())
                            {
                                code.AppendLine("try");
                                code.AppendLine("{");
                                using (code.Indent())
                                {
                                    code.AppendLine($"{Variable.DisposablesFieldName}[{Variable.DisposeIndexFieldName}].Dispose();");
                                }

                                code.AppendLine("}");
                                code.AppendLine("catch");
                                code.AppendLine("{");
                                using (code.Indent())
                                {
                                    code.AppendLine("// ignored");
                                }

                                code.AppendLine("}");
                            }

                            code.AppendLine("}");
                            code.AppendLine();
                        }

                        foreach (var singletonField in singletonFields)
                        {
                            code.AppendLine(
                                singletonField.Key.Type.IsValueType
                                    ? $"{singletonField.Value}Created = false;"
                                    : $"{singletonField.Value} = null;");
                        }
                    }

                    code.AppendLine("}");
                }

                code.AppendLine("}");
            }
        }

        code.AppendLine("}");

        // ReSharper disable once InvertIf
        if (!string.IsNullOrWhiteSpace(ns))
        {
            // ReSharper disable once RedundantAssignment
            nsIndent.Dispose();
            code.AppendLine("}");
        }

        return string.Join(Environment.NewLine, code);
    }

    private static ImmutableArray<Line> BuildProperty(ITypeSymbol type, Root root, in ImmutableArray<Line> lines)
    {
        var code = new LinesBuilder();
        code.AppendLine($"{(root.IsPublic ? "public" : "private")} {type} {root.PropertyName}");
        code.AppendLine("{");
        using (code.Indent())
        {
            code.AppendLine(MethodImplOptions);
            code.AppendLine("get");
            code.AppendLine("{");
            using (code.Indent())
            {
                code.AppendLines(lines);
            }

            code.AppendLine("}");
        }

        code.AppendLine("}");
        return code.Lines.ToImmutableArray();
    }
}