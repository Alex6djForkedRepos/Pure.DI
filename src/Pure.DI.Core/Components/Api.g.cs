// <auto-generated/>
#if !PUREDI_API_SUPPRESSION || PUREDI_API_V2
#pragma warning disable

#if !NET40_OR_GREATER && !NETSTANDARD2_0_OR_GREATER && !NETCOREAPP2_0_OR_GREATER && !NET5_0_OR_GREATER
namespace System.Diagnostics.CodeAnalysis
{
    // ReSharper disable UnusedType.Global
    [global::System.AttributeUsage(global::System.AttributeTargets.Assembly | global::System.AttributeTargets.Class | global::System.AttributeTargets.Constructor | global::System.AttributeTargets.Event | global::System.AttributeTargets.Method | global::System.AttributeTargets.Property | global::System.AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
    internal sealed class ExcludeFromCodeCoverageAttribute : global::System.Attribute
    {
    }
}
#endif

#if NET20
namespace System
{
    internal delegate TResult Func<TResult>();
    internal delegate TResult Func<T, TResult>(T arg);
}
#endif

namespace Pure.DI
{
    using global::System;
    using global::System.Diagnostics;

    /// <summary>
    /// Binding lifetimes.
    /// <example>
    /// <code>
    /// DI.Setup("Composition")
    ///     .Bind&lt;IDependency&gt;().As(Lifetime.Singleton).To&lt;Dependency&gt;();
    /// </code>
    /// See also:
    /// <br/><see cref="Pure.DI.DI.Setup"/>
    /// <br/><see cref="IBinding.As"/>
    /// <br/><see cref="IConfiguration.DefaultLifetime"/>
    /// </example>
    /// </summary>
    internal enum Lifetime
    {
        /// <summary>
        /// Specifies to create a new dependency instance each time. This is the default value and can be omitted.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().As(Lifetime.Transient).To&lt;Dependency&gt;();
        /// </code>
        /// This is the default lifetime, it can be omitted, for example:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        Transient,

        /// <summary>
        /// Ensures that there will be a single instance of the dependency for each composition.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().As(Lifetime.Singleton).To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        Singleton,

        /// <summary>
        /// Guarantees that there will be a single instance of the dependency for each root of the composition.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().As(Lifetime.PerResolve).To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        PerResolve,
        
        /// <summary>
        /// Does not guarantee that there will be a single instance of the dependency for each root of the composition, but is useful to reduce the number of instances of type.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().As(Lifetime.PerBlock).To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        PerBlock,
        
        /// <summary>
        /// Ensures that there will be a single instance of the dependency for each scope.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().As(Lifetime.Singleton).To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// </summary>
        Scoped
    }
    
    /// <summary>
    /// Hints for the code generator and can be used to fine tune code generation.
    /// <example>
    /// <code>
    /// // Resolve = Off
    /// DI.Setup("Composition")
    ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
    /// </code>
    /// or using the API call <see cref="IConfiguration.Hint"/>:
    /// <code>
    /// DI.Setup("Composition")
    ///     .Hint(Hint.Resolve, "Off")
    ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
    /// </code>
    /// See also:
    /// <br/><see cref="IConfiguration.Hint"/>
    /// </example>
    /// </summary>
    internal enum Hint
    {
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Determines whether to generate <c>Resolve</c> methods. <c>On</c> by default.
        /// <example>
        /// <code>
        /// // Resolve = Off
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.Resolve, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        Resolve,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Determines whether to use partial <c>OnNewInstance</c> method. <c>Off</c> by default.
        /// <example>
        /// <code>
        /// // OnNewInstance = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstance, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnNewInstance,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Determines whether to generate partial <c>OnNewInstance</c> method when the _OnNewInstance_ hint is <c>On</c>. <c>On</c> by default.
        /// <example>
        /// <code>
        /// // OnNewInstancePartial = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstancePartial, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnNewInstancePartial,
        
        /// <summary>
        /// The regular expression to filter OnNewInstance by the instance type name. ".+" by default.
        /// <example>
        /// <code>
        /// // OnNewInstanceImplementationTypeNameRegularExpression = Dependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstanceImplementationTypeNameRegularExpression, "Dependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnNewInstanceImplementationTypeNameRegularExpression,
        
        /// <summary>
        /// The regular expression to filter OnNewInstance by the tag. ".+" by default.
        /// <example>
        /// <code>
        /// // OnNewInstanceTagRegularExpression = IDependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstanceTagRegularExpression, "IDependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnNewInstanceTagRegularExpression,
        
        /// <summary>
        /// The regular expression to filter OnNewInstance by the lifetime. ".+" by default.
        /// <example>
        /// <code>
        /// // OnNewInstanceLifetimeRegularExpression = Singleton
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewInstanceLifetimeRegularExpression, "Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnNewInstanceLifetimeRegularExpression,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Determines whether to use partial <c>OnDependencyInjection</c> method to control of dependency injection. <c>Off</c> by default.
        /// <example>
        /// <code>
        /// // OnDependencyInjection = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjection, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnDependencyInjection,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Determines whether to generate partial <c>OnDependencyInjection</c> method when the _OnDependencyInjection_ hint is <c>On</c> to control of dependency injection. <c>On</c> by default.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionPartial = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionPartial, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnDependencyInjectionPartial,
        
        /// <summary>
        /// The regular expression to filter OnDependencyInjection by the instance type name. ".+" by default.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionImplementationTypeNameRegularExpression = Dependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionImplementationTypeNameRegularExpression, "Dependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnDependencyInjectionImplementationTypeNameRegularExpression,
        
        /// <summary>
        /// The regular expression to filter OnDependencyInjection by the resolving type name. ".+" by default.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionContractTypeNameRegularExpression = IDependency
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionContractTypeNameRegularExpression, "IDependency")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnDependencyInjectionContractTypeNameRegularExpression,
        
        /// <summary>
        /// The regular expression to filter OnDependencyInjection by the tag. ".+" by default.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionTagRegularExpression = MyTag
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;("MyTag").To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionTagRegularExpression, "MyTag")
        ///     .Bind&lt;IDependency&gt;("MyTag").To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnDependencyInjectionTagRegularExpression,
        
        /// <summary>
        /// The regular expression to filter OnDependencyInjection by the lifetime. ".+" by default.
        /// <example>
        /// <code>
        /// // OnDependencyInjectionLifetimeRegularExpression = Singleton
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnDependencyInjectionLifetimeRegularExpression, "Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnDependencyInjectionLifetimeRegularExpression,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Determines whether to use a partial <c>OnCannotResolve&lt;T&gt;(...)</c> method to handle a scenario in which the dependency cannot be resolved. <c>Off</c> by default.
        /// <example>
        /// <code>
        /// // OnCannotResolve = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolve, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnCannotResolve,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Determines whether to generate a partial <c>OnCannotResolve&lt;T&gt;(...)</c> method when the <c>OnCannotResolve</c> hint is <c>On</c> to handle a scenario in which the dependency cannot be resolved. <c>On</c> by default.
        /// <example>
        /// <code>
        /// // OnCannotResolvePartial = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolvePartial, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnCannotResolvePartial,
        
        /// <summary>
        /// The regular expression to filter OnCannotResolve by the resolving type name. ".+" by default.
        /// <example>
        /// <code>
        /// // OnCannotResolveContractTypeNameRegularExpression = OtherType
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolveContractTypeNameRegularExpression, "OtherType")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnCannotResolveContractTypeNameRegularExpression,
        
        /// <summary>
        /// The regular expression to filter OnCannotResolve by the tag. ".+" by default.
        /// <example>
        /// <code>
        /// // OnCannotResolveTagRegularExpression = MyTag
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolveTagRegularExpression, "MyTag")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnCannotResolveTagRegularExpression,
        
        /// <summary>
        /// The regular expression to filter OnCannotResolve by the lifetime. ".+" by default.
        /// <example>
        /// <code>
        /// // OnCannotResolveLifetimeRegularExpression = Singleton
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnCannotResolveLifetimeRegularExpression, "Singleton")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnCannotResolveLifetimeRegularExpression,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Determines whether to use a static partial <c>OnNewRoot&lt;T&gt;(...)</c> method to handle the new Composition root registration event. <c>Off</c> by default.
        /// <example>
        /// <code>
        /// // OnNewRoot = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewRoot, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnNewRoot,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Determines whether to generate a static partial <c>OnNewRoot&lt;T&gt;(...)</c> method when the <c>OnNewRoot</c> hint is <c>On</c> to handle the new Composition root registration event. <c>On</c> by default.
        /// <example>
        /// <code>
        /// // OnNewRootPartial = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.OnNewRootPartial, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        OnNewRootPartial,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Determine if the <c>ToString()</c> method should be generated. This method provides a text-based class diagram in the format mermaid. <c>Off</c> by default. 
        /// <example>
        /// <code>
        /// // ToString = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ToString, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        ToString,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. This hint determines whether object Composition will be created in a thread-safe manner. <c>On</c> by default. 
        /// <example>
        /// <code>
        /// // ThreadSafe = Off
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ThreadSafe, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        ThreadSafe,
        
        /// <summary>
        /// Overrides modifiers of the method <c>public T Resolve&lt;T&gt;()</c>. "public" by default.
        /// <example>
        /// <code>
        /// // ResolveMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ResolveMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        ResolveMethodModifiers,
        
        /// <summary>
        /// Overrides name of the method <c>public T Resolve&lt;T&gt;()</c>. "Resolve" by default.
        /// <example>
        /// <code>
        /// // ResolveMethodName = GetService
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ResolveMethodName, "GetService")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        ResolveMethodName,
        
        /// <summary>
        /// Overrides modifiers of the method <c>public T Resolve&lt;T&gt;(object? tag)</c>. "public" by default.
        /// <example>
        /// <code>
        /// // ResolveByTagMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ResolveByTagMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        ResolveByTagMethodModifiers,
        
        /// <summary>
        /// Overrides name of the method <c>public T Resolve&lt;T&gt;(object? tag)</c>. "Resolve" by default.
        /// <example>
        /// For example:
        /// <code>
        /// // ResolveByTagMethodName = GetService
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ResolveByTagMethodName, "GetService")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        ResolveByTagMethodName,
        
        /// <summary>
        /// Overrides modifiers of the method <c>public object Resolve(Type type)</c>. "public" by default.
        /// <example>
        /// <code>
        /// // ObjectResolveMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ObjectResolveMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        ObjectResolveMethodModifiers,
        
        /// <summary>
        /// Overrides name of the method <c>public object Resolve(Type type)</c>. "Resolve" by default.
        /// <example>
        /// <code>
        /// // ObjectResolveMethodName = GetService
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ObjectResolveMethodName, "GetService")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        ObjectResolveMethodName,
        
        /// <summary>
        /// Overrides modifiers of the method <c>public object Resolve(Type type, object? tag)</c>. "public" by default.
        /// <example>
        /// <code>
        /// // ObjectResolveByTagMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ObjectResolveByTagMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        ObjectResolveByTagMethodModifiers,
        
        /// <summary>
        /// Overrides name of the method <c>public object Resolve(Type type, object? tag)</c>. "Resolve" by default.
        /// <example>
        /// <code>
        /// // ObjectResolveByTagMethodName = GetService
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.ObjectResolveByTagMethodName, "GetService")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        ObjectResolveByTagMethodName,
        
        /// <summary>
        /// Overrides modifiers of the method <c>public void Dispose()</c>. "public" by default.
        /// <example>
        /// <code>
        /// // DisposeMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisposeMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        DisposeMethodModifiers,
        
        /// <summary>
        /// Overrides modifiers of the method <c>public <see cref="ValueTask"/> DisposeAsyncMethodModifiers()</c>. "public" by default.
        /// <example>
        /// <code>
        /// // DisposeAsyncMethodModifiers = internal
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.DisposeAsyncMethodModifiers, "internal")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        DisposeAsyncMethodModifiers,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Specifies whether the generated code should be formatted. This option consumes a lot of CPU resources. <c>Off</c> by default.
        /// <example>
        /// <code>
        /// // FormatCode = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.FormatCode, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        FormatCode,
        
        /// <summary>
        /// <c>Error</c> or <c>Warning</c> or <c>Info</c> or <c>Hidden</c>. Indicates the severity level of the situation when, in the binding, an implementation does not implement a contract. <c>Error</c> by default.
        /// <example>
        /// <code>
        /// // FormatCode = On
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.SeverityOfNotImplementedContracts, "On")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        SeverityOfNotImplementedContract,
        
        /// <summary>
        /// <c>On</c> or <c>Off</c>. Specifies whether the generated code should be commented. <c>On</c> by default.
        /// <example>
        /// <code>
        /// // Comments = Off
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// <br/>
        /// or using the API call <see cref="IConfiguration.Hint"/>:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Hint.Comments, "Off")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Hint"/>
        /// </example>
        /// </summary>
        Comments
    }

    /// <summary>
    /// Represents a generic type argument marker. It allows you to create custom generic type argument marker such as <see cref="TTS"/>, <see cref="TTDictionary{TKey,TValue}"/>, etc. 
    /// <example>
    /// <code>
    /// [GenericTypeArgument]
    /// internal interface TTMy: IMy { }
    /// </code>
    /// </example>
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Class | global::System.AttributeTargets.Interface | global::System.AttributeTargets.Struct)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal sealed class GenericTypeArgumentAttribute : global::System.Attribute { }
    
    /// <summary>
    /// Represents an ordinal attribute.
    /// This attribute is part of the API, but you can use your own attribute at any time, and this allows you to define them in the assembly and namespace you want.
    /// <example>
    /// For constructors, it defines the sequence of attempts to use a particular constructor to create an object:
    /// <code>
    /// class Service : IService
    /// {
    ///     private readonly string _name;
    /// 
    ///
    ///     [Ordinal(1)]
    ///     public Service(IDependency dependency) =&gt;
    ///         _name = "with dependency";
    /// 
    ///
    ///     [Ordinal(0)]
    ///     public Service(string name) =&gt; _name = name;
    /// }
    /// </code>
    /// <br/>
    /// For fields, properties and methods, it specifies to perform dependency injection and defines the sequence:
    /// <code>
    /// class Person : IPerson
    /// {
    ///     private readonly string _name = "";
    /// 
    ///     [Ordinal(0)]
    ///     public int Id;
    ///
    /// 
    ///     [Ordinal(1)]
    ///     public string FirstName
    ///     {
    ///         set
    ///         {
    ///             _name = value;
    ///         }
    ///     }
    /// 
    ///
    ///     public IDependency? Dependency { get; private set; }
    /// 
    ///
    ///     [Ordinal(2)]
    ///     public void SetDependency(IDependency dependency) =&gt;
    ///         Dependency = dependency;
    /// }
    /// </code>
    /// See also:
    /// <br/><see cref="TagAttribute"/>
    /// <br/><see cref="TypeAttribute"/>
    /// </example>
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Constructor | global::System.AttributeTargets.Method | global::System.AttributeTargets.Property | global::System.AttributeTargets.Field, AllowMultiple = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal class OrdinalAttribute : global::System.Attribute
    {
        /// <summary>
        /// Creates an attribute instance.
        /// </summary>
        /// <param name="ordinal">The injection ordinal.</param>
        public OrdinalAttribute(int ordinal) { }
    }

    /// <summary>
    /// Represents a tag attribute overriding an injection tag. The tag can be a constant, a type, or a value of an enumerated type.
    /// This attribute is part of the API, but you can use your own attribute at any time, and this allows you to define them in the assembly and namespace you want.
    /// <example>
    /// Sometimes it's important to take control of building a dependency graph. For example, when there are multiple implementations of the same contract. In this case, tags will help:
    /// <code>
    /// interface IDependency { }
    /// 
    ///
    /// class AbcDependency : IDependency { }
    /// 
    ///
    /// class XyzDependency : IDependency { }
    /// 
    ///
    /// class Dependency : IDependency { }
    /// 
    ///
    /// interface IService
    /// {
    ///     IDependency Dependency1 { get; }
    /// 
    ///
    ///     IDependency Dependency2 { get; }
    /// }
    ///
    /// 
    /// class Service : IService
    /// {
    ///     public Service(
    ///         [Tag("Abc")] IDependency dependency1,
    ///         [Tag("Xyz")] IDependency dependency2)
    ///     {
    ///         Dependency1 = dependency1;
    ///         Dependency2 = dependency2;
    ///     }
    ///
    ///     public IDependency Dependency1 { get; }
    ///
    /// 
    ///     public IDependency Dependency2 { get; }
    /// }
    ///
    /// 
    /// DI.Setup("Composition")
    ///     .Bind&lt;IDependency&gt;("Abc").To&lt;AbcDependency&gt;()
    ///     .Bind&lt;IDependency&gt;("Xyz").To&lt;XyzDependency&gt;()
    ///     .Bind&lt;IService&gt;().To&lt;Service&gt;().Root&lt;IService&gt;("Root");
    /// </code>
    /// See also:
    /// <br/><see cref="OrdinalAttribute"/>
    /// <br/><see cref="TypeAttribute"/>
    /// </example>
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter | global::System.AttributeTargets.Property | global::System.AttributeTargets.Field, AllowMultiple = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal class TagAttribute : global::System.Attribute
    {
        /// <summary>
        /// Creates an attribute instance.
        /// </summary>
        /// <param name="tag">The injection tag. See also <see cref="IBinding.Tags"/></param>.
        public TagAttribute(object tag) { }
    }

    /// <summary>
    /// The injection type can be defined manually using the <c>Type</c> attribute.This attribute explicitly overrides an injected type, otherwise it would be determined automatically based on the type of the constructor/method, property, or field parameter.
    /// This attribute is part of the API, but you can use your own attribute at any time, and this allows you to define them in the assembly and namespace you want.
    /// <example>
    /// <code>
    /// interface IDependency { }
    /// 
    ///
    /// class AbcDependency : IDependency { }
    ///
    ///
    /// class XyzDependency : IDependency { }
    ///
    ///
    /// interface IService
    /// {
    ///     IDependency Dependency1 { get; }
    ///
    ///     IDependency Dependency2 { get; }
    /// }
    ///
    ///
    /// class Service : IService
    /// {
    ///     public Service(
    ///         [Type(typeof(AbcDependency))] IDependency dependency1,
    ///         [Type(typeof(XyzDependency))] IDependency dependency2)
    ///     {
    ///         Dependency1 = dependency1;
    ///         Dependency2 = dependency2;
    ///     }
    ///
    ///
    ///     public IDependency Dependency1 { get; }
    ///
    ///
    ///     public IDependency Dependency2 { get; }
    /// }
    ///
    ///
    /// DI.Setup("Composition")
    ///     .Bind&lt;IService&gt;().To&lt;Service&gt;().Root&lt;IService&gt;("Root");
    /// </code>
    /// See also:
    /// <br/><see cref="TagAttribute"/>
    /// <br/><see cref="OrdinalAttribute"/>
    /// </example>
    /// </summary>
    [global::System.AttributeUsage(global::System.AttributeTargets.Parameter | global::System.AttributeTargets.Property | global::System.AttributeTargets.Field, AllowMultiple = false)]
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal class TypeAttribute : global::System.Attribute
    {
        /// <summary>
        /// Creates an attribute instance.
        /// </summary>
        /// <param name="type">The injection type. See also <see cref="IConfiguration.Bind{T}"/> and <see cref="IBinding.Bind{T}"/>.</param>
        public TypeAttribute(global::System.Type type) { }
    }

    /// <summary>
    /// Determines how the partial class will be generated. The <see cref="DI.Setup"/> method has an additional argument <c>kind</c>, which defines the type of composition:
    /// <example>
    /// <code>
    /// DI.Setup("BaseComposition", CompositionKind.Internal);
    /// </code>
    /// See also:
    /// <br/><see cref="DI.Setup"/>
    /// </example>
    /// </summary>
    internal enum CompositionKind
    {
        /// <summary>
        /// This value is used by default. If this value is specified, a normal partial class will be generated.
        /// </summary>
        Public,
        
        /// <summary>
        /// If this value is specified, the class will not be generated, but this setting can be used by other users as a baseline. The API call <see cref="IConfiguration.DependsOn"/> is mandatory.
        /// </summary>
        Internal,
        
        /// <summary>
        /// No partial classes will be created when this value is specified, but this setting is the baseline for all installations in the current project, and the API call <see cref="IConfiguration.DependsOn"/> is not required.
        /// </summary>
        Global
    }

    /// <summary>
    /// Determines a kind of root of the composition.
    /// <br/>See also:
    /// <br/><see cref="IConfiguration.Root{T}"/>
    /// </summary>
    [Flags]
    internal enum RootKinds
    {
        /// <summary>
        /// Specifies to use the default composition root kind.
        /// </summary>
        Default = RootKinds.Public | RootKinds.Property,
        
        /// <summary>
        /// Specifies to use a <c>public</c> access modifier for the root of the composition.
        /// </summary>
        Public = 1,
        
        /// <summary>
        /// Specifies to use a <c>internal</c> access modifier for the root of the composition.
        /// </summary>
        Internal = 2,
        
        /// <summary>
        /// Specifies to use a <c>private</c> access modifier for the root of the composition.
        /// </summary>
        Private = 4,
        
        /// <summary>
        /// Specifies to create a composition root as a property.
        /// </summary>
        Property = 8,
        
        /// <summary>
        /// Specifies to create a composition root as a method.
        /// </summary>
        Method = 16,
        
        /// <summary>
        /// Specifies to create a static root of the composition.
        /// </summary>
        Static = 32,
        
        /// <summary>
        /// Specifies to create a partial root of the composition.
        /// </summary>
        Partial = 64
    }
    
    /// <summary>
    /// Represents well known tags.
    /// </summary>
    internal enum Tag
    {
        /// <summary>
        /// Unique tag.
        /// Begins the definition of the binding.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;(Tag.Unique).To&lt;Service1&gt;()
        ///     .Bind&lt;IService&gt;(Tag.Unique).To&lt;Service1&gt;()
        ///     .Root&lt;IEnumerable&lt;IService&gt;&gt;("Root");
        /// </code>
        /// </example>
        /// </summary>
        Unique,
        
        /// <summary>
        /// Tag of target implementation type.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;(Tag.Type).To&lt;Service&gt;()
        ///     .Root&lt;IService&gt;("Root", typeof(Service));
        /// </code>
        /// </example>
        /// </summary>
        Type
    }

    /// <summary>
    /// Gives the ability to manage disposable objects.
    /// </summary>
    internal interface IOwned
        : global::System.IDisposable
#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
        , global::System.IAsyncDisposable
#endif
    {
    }

    /// <summary>
    /// Gives the ability to manage disposable objects.
    /// </summary>
    internal sealed partial class Owned : global::System.Collections.Generic.List<object>, global::Pure.DI.IOwned
    {
        /// <inheritdoc />
        public void Dispose()
        {
            for (var i = Count - 1; i >= 0; i--)
            {
                switch (this[i])
                {
                    case global::Pure.DI.IOwned _:
                        break;

                    case global::System.IDisposable disposableInstance:
                        try
                        {
                            disposableInstance.Dispose();
                        }
                        catch (global::System.Exception exception)
                        {
                            OnDisposeException(disposableInstance, exception);
                        }
                        break;

#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
                    case global::System.IAsyncDisposable asyncDisposableInstance:
                        try
                        {
                            var valueTask = asyncDisposableInstance.DisposeAsync();
                            if (!valueTask.IsCompleted)
                            {
                                valueTask.AsTask().Wait();
                            }
                        }
                        catch (global::System.Exception exception)
                        {
                            OnDisposeAsyncException(asyncDisposableInstance, exception);
                        }
                        break;
#endif
                }
            }
        }

#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
        /// <inheritdoc />
        public async global::System.Threading.Tasks.ValueTask DisposeAsync()
        {
            for (var i = Count - 1; i >= 0; i--)
            {
                switch (this[i])
                {
                    case global::Pure.DI.IOwned _:
                        break;

                    case global::System.IAsyncDisposable asyncDisposableInstance:
                        try
                        {
                            await asyncDisposableInstance.DisposeAsync();
                        }
                        catch (global::System.Exception exception)
                        {
                            OnDisposeAsyncException(asyncDisposableInstance, exception);
                        }
                        break;

                    case global::System.IDisposable disposableInstance:
                        try
                        {
                            disposableInstance.Dispose();
                        }
                        catch (global::System.Exception exception)
                        {
                            OnDisposeException(disposableInstance, exception);
                        }
                        break;
                }
            }
        }
#endif                


        /// <summary>
        /// Implement this partial method to handle the exception on disposing.
        /// </summary>
        /// <param name="disposableInstance">The disposable instance.</param>
        /// <param name="exception">Exception occurring during disposal.</param>
        /// <typeparam name="T">The actual type of instance being disposed of.</typeparam>
        partial void OnDisposeException<T>(T disposableInstance, Exception exception)
            where T : global::System.IDisposable;
        
#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER        
        /// <summary>
        /// Implement this partial method to handle the exception on disposing.
        /// </summary>
        /// <param name="asynDisposableInstance">The disposable instance.</param>
        /// <param name="exception">Exception occurring during disposal.</param>
        /// <typeparam name="T">The actual type of instance being disposed of.</typeparam>
        partial void OnDisposeAsyncException<T>(T asynDisposableInstance, Exception exception)
            where T : global::System.IAsyncDisposable;
#endif
    }
    
    /// <summary>
    /// Contains a value and gives the ability to manage disposable objects.
    /// </summary>
    [global::System.Diagnostics.DebuggerDisplay("{Value}")]
    [global::System.Diagnostics.DebuggerTypeProxy(typeof(global::Pure.DI.Owned<>.DebugView))]
    internal readonly struct Owned<T> : global::Pure.DI.IOwned
    {
        /// <summary>
        /// The value.
        /// </summary>
        public readonly T Value;
        private readonly global::Pure.DI.IOwned _owned;
        
        public Owned(T value, global::Pure.DI.IOwned owned)
        {
            Value = value;
            _owned = owned;
        }

        /// <inheritdoc />
        public void Dispose()
        {
            _owned.Dispose();
        }
        
#if NETCOREAPP3_0_OR_GREATER || NETSTANDARD2_1_OR_GREATER
        /// <inheritdoc />
        public global::System.Threading.Tasks.ValueTask DisposeAsync()
        {
            return _owned.DisposeAsync();
        }
#endif        
        
        private class DebugView
        {
            private readonly global::Pure.DI.Owned<T> _owned;

            public DebugView(global::Pure.DI.Owned<T> owned)
            {
                _owned = owned;
            }
            
            public T Value
            {
                get { return _owned.Value; }
            }
                
            [global::System.Diagnostics.DebuggerBrowsable(DebuggerBrowsableState.Collapsed)]
            public global::Pure.DI.IOwned Owned
            {
                get { return _owned._owned; }
            }
        }
    }

    /// <summary>
    /// An API for a Dependency Injection setup.
    /// <br/>See also:
    /// <br/><see cref="DI.Setup"/>
    /// </summary>
    internal interface IConfiguration
    {
        /// <summary>
        /// Begins the binding definition for the implementation type itself, and if the implementation is not an abstract class or structure, for all abstract but NOT special types that are directly implemented.
        /// Special types include:
        /// <list type="bullet">
        /// <item>System.Object</item>
        /// <item>System.Enum</item>
        /// <item>System.MulticastDelegate</item>
        /// <item>System.Delegate</item>
        /// <item>System.Collections.IEnumerable</item>
        /// <item>System.Collections.Generic.IEnumerable&lt;T&gt;</item>
        /// <item>System.Collections.Generic.IList&lt;T&gt;</item>
        /// <item>System.Collections.Generic.ICollection&lt;T&gt;</item>
        /// <item>System.Collections.IEnumerator</item>
        /// <item>System.Collections.Generic.IEnumerator&lt;T&gt;</item>
        /// <item>System.Collections.Generic.IIReadOnlyList&lt;T&gt;</item>
        /// <item>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</item>
        /// <item>System.IDisposable</item>
        /// <item>System.IAsyncResult</item>
        /// <item>System.AsyncCallback</item>
        /// </list>
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind().To&lt;Service&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </example>
        /// </summary>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind(params object[] tags);
        
        /// <summary>
        /// Begins the definition of the binding.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;().To&lt;Service&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </example>
        /// </summary>
        /// <typeparam name="T">The type of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T4">The type 4 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3, T4>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T4">The type 4 of dependency to be bound.</typeparam>
        /// <typeparam name="T5">The type 5 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3, T4, T5>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T4">The type 4 of dependency to be bound.</typeparam>
        /// <typeparam name="T5">The type 5 of dependency to be bound.</typeparam>
        /// <typeparam name="T6">The type 6 of dependency to be bound.</typeparam> 
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3, T4, T5, T6>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T4">The type 4 of dependency to be bound.</typeparam>
        /// <typeparam name="T5">The type 5 of dependency to be bound.</typeparam>
        /// <typeparam name="T6">The type 6 of dependency to be bound.</typeparam>
        /// <typeparam name="T7">The type 7 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3, T4, T5, T6, T7>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T4">The type 4 of dependency to be bound.</typeparam>
        /// <typeparam name="T5">The type 5 of dependency to be bound.</typeparam>
        /// <typeparam name="T6">The type 6 of dependency to be bound.</typeparam>
        /// <typeparam name="T7">The type 7 of dependency to be bound.</typeparam>
        /// <typeparam name="T8">The type 8 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3, T4, T5, T6, T7, T8>(params object[] tags);

        /// <summary>
        /// Begins the definition of the binding with <see cref="Root{T}"/> applied.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .RootBind&lt;IService&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </example>
        /// </summary>
        /// <typeparam name="T">The type of dependency to be bound.</typeparam>
        /// <param name="name">Specifies the unique name of the root of the composition. If the value is empty, a private root will be created, which can be used when calling <c>Resolve</c> methods.</param>
        /// <param name="kind">The Optional argument specifying the kind for the root of the Composition.</param>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding. If is is not empty, the first tag is used for the root.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding RootBind<T>(string name = "", RootKinds kind = RootKinds.Default, params object[] tags);

        /// <summary>
        /// Indicates the use of some single or multiple setups as base setups by name.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .DependsOn(nameof(CompositionBase));
        /// </code>
        /// See also:
        /// <br/><see cref="DI.Setup"/>
        /// </example>
        /// </summary>
        /// <param name="setupNames">A set of names for the basic setups on which this one depends.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration DependsOn(params string[] setupNames);

        /// <summary>
        /// Specifies a custom attribute that overrides the injection type.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .TypeAttribute&lt;MyTypeAttribute&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="Pure.DI.TypeAttribute"/>
        /// </example>
        /// </summary>
        /// <param name="typeArgumentPosition">The optional parameter that specifies the position of the type parameter in the attribute constructor. 0 by default. See predefined attribute <see cref="TypeAttribute{T}"/>.</param>
        /// <typeparam name="T">The attribute type.</typeparam>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration TypeAttribute<T>(int typeArgumentPosition = 0) where T : global::System.Attribute;

        /// <summary>
        /// Specifies a tag attribute that overrides the injected tag.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .TagAttribute&lt;MyTagAttribute&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="Pure.DI.TagAttribute"/>
        /// </example>
        /// </summary>
        /// <param name="tagArgumentPosition">The optional parameter that specifies the position of the tag parameter in the attribute constructor. 0 by default. See the predefined <see cref="TagAttribute{T}"/> attribute.</param>
        /// <typeparam name="T">The attribute type.</typeparam>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration TagAttribute<T>(int tagArgumentPosition = 0) where T : global::System.Attribute;

        /// <summary>
        /// Specifies a custom attribute that overrides the injection ordinal.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .OrdinalAttribute&lt;MyOrdinalAttribute&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="Pure.DI.OrdinalAttribute"/>
        /// </example>
        /// </summary>
        /// <param name="ordinalArgumentPosition">The optional parameter that specifies the position of the ordinal parameter in the attribute constructor. 0 by default. See the predefined <see cref="OrdinalAttribute{T}"/> attribute.</param>
        /// <typeparam name="T">The attribute type.</typeparam>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration OrdinalAttribute<T>(int ordinalArgumentPosition = 0) where T : global::System.Attribute;

        /// <summary>
        /// Overrides the default <see cref="Lifetime"/> for all bindings further down the chain. If not specified, the <see cref="Lifetime.Transient"/> lifetime is used.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .DefaultLifetime(Lifetime.Singleton);
        /// </code>
        /// See also:
        /// <br/><see cref="Pure.DI.Lifetime"/>
        /// <br/><see cref="IBinding.As"/>
        /// </example>
        /// </summary>
        /// <param name="lifetime">The default lifetime.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration DefaultLifetime(Pure.DI.Lifetime lifetime);
        
        /// <summary>
        /// Adds a partial class argument and replaces the default constructor by adding this argument as a parameter. It is only created if this argument is actually used. 
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Arg&lt;int&gt;("id");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="name">The argument name.</param>
        /// <param name="tags">The optional argument that specifies the tags for the argument.</param>
        /// <typeparam name="T">The argument type.</typeparam>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration Arg<T>(string name, params object[] tags);
        
        /// <summary>
        /// Adds a root argument to use as a root parameter. 
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .RootArg&lt;int&gt;("id");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="name">The argument name.</param>
        /// <param name="tags">The optional argument that specifies the tags for the argument.</param>
        /// <typeparam name="T">The argument type.</typeparam>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration RootArg<T>(string name, params object[] tags);
        
        /// <summary>
        /// Specifying the root of the Composition.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Root&lt;Service&gt;("MyService");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="name">Specifies the unique name of the root of the composition. If the value is empty, a private root will be created, which can be used when calling <c>Resolve</c> methods.</param>
        /// <param name="tag">Optional argument specifying the tag for the root of the Composition.</param>
        /// <typeparam name="T">The Composition root type.</typeparam>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration Root<T>(string name = "", object tag = null, RootKinds kind = RootKinds.Default);

        /// <summary>
        /// Defines a hint for fine-tuning code generation.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Hint(Resolve, "Off");
        /// </code>
        /// See also:
        /// <br/><see cref="Pure.DI.Hint"/>
        /// </example>
        /// </summary>
        /// <param name="hint">The hint type.</param>
        /// <param name="value">The hint value.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration Hint(Hint hint, string value);

        /// <summary>
        /// Registers an accumulator for instances.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Accumulate&lt;IDisposable, MyAccumulator&gt;(Lifetime.Transient);
        /// </code>
        /// See also:
        /// <br/><see cref="Pure.DI.Hint"/>
        /// <br/><see cref="Pure.DI.Lifetime"/>
        /// </example>
        /// </summary>
        /// <param name="lifetimes"><see cref="Lifetime"/> of the instances to be accumulated. Instances with lifetime <see cref="Lifetime.Singleton"/>, <see cref="Lifetime.Scoped"/>, or <see cref="Lifetime.PerResolve"/> only accumulate in an accumulator that is NOT lazily created.</param>
        /// <typeparam name="T">The type of instance. All instances that can be cast to this type will be aacumulated.</typeparam>
        /// <typeparam name="TAccumulator">The type of accumulator. It must have a public constructor without parameters and a <c>Add</c> method with a single argument that allows you to add an instance of type <typeparamref name="T"/>.</typeparam>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration Accumulate<T, TAccumulator>(params Lifetime[] lifetimes)
            where TAccumulator: new();
    }

    /// <summary>
    /// An API for a binding setup.
    /// </summary>
    internal interface IBinding
    {
        /// <summary>
        /// Begins the binding definition for the implementation type itself, and if the implementation is not an abstract class or structure, for all abstract but NOT special types that are directly implemented.
        /// Special types include:
        /// <list type="bullet">
        /// <item>System.Object</item>
        /// <item>System.Enum</item>
        /// <item>System.MulticastDelegate</item>
        /// <item>System.Delegate</item>
        /// <item>System.Collections.IEnumerable</item>
        /// <item>System.Collections.Generic.IEnumerable&lt;T&gt;</item>
        /// <item>System.Collections.Generic.IList&lt;T&gt;</item>
        /// <item>System.Collections.Generic.ICollection&lt;T&gt;</item>
        /// <item>System.Collections.IEnumerator</item>
        /// <item>System.Collections.Generic.IEnumerator&lt;T&gt;</item>
        /// <item>System.Collections.Generic.IIReadOnlyList&lt;T&gt;</item>
        /// <item>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</item>
        /// <item>System.IDisposable</item>
        /// <item>System.IAsyncResult</item>
        /// <item>System.AsyncCallback</item>
        /// </list>
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind().To&lt;Service&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </example>
        /// </summary>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind(params object[] tags);
        
        /// <summary>
        /// Begins the definition of the binding.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// </example>
        /// See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </summary>
        /// <typeparam name="T">The type of dependency to be bound. Common type markers such as <see cref="TT"/>, <see cref="TTList{T}"/> and others are also supported.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// <br/>See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// <br/>See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// <br/>See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T4">The type 3 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3, T4>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// <br/>See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T4">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T5">The type 5 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3, T4, T5>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// <br/>See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T4">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T5">The type 5 of dependency to be bound.</typeparam>
        /// <typeparam name="T6">The type 6 of dependency to be bound.</typeparam> 
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3, T4, T5, T6>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// <br/>See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T4">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T5">The type 5 of dependency to be bound.</typeparam>
        /// <typeparam name="T6">The type 6 of dependency to be bound.</typeparam>
        /// <typeparam name="T7">The type 7 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3, T4, T5, T6, T7>(params object[] tags);
        
        /// <summary>
        /// Begins binding definition for multiple dependencies. See <see cref="Bind{T}"/> for examples.
        /// <br/>See also:
        /// <br/><see cref="IBinding.As"/>
        /// <br/><see cref="IBinding.To{T}()"/>
        /// </summary>
        /// <typeparam name="T1">The type 1 of dependency to be bound.</typeparam>
        /// <typeparam name="T2">The type 2 of dependency to be bound.</typeparam>
        /// <typeparam name="T3">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T4">The type 3 of dependency to be bound.</typeparam>
        /// <typeparam name="T5">The type 5 of dependency to be bound.</typeparam>
        /// <typeparam name="T6">The type 6 of dependency to be bound.</typeparam>
        /// <typeparam name="T7">The type 7 of dependency to be bound.</typeparam>
        /// <typeparam name="T8">The type 8 of dependency to be bound.</typeparam>
        /// <param name="tags">The optional argument that specifies tags for a particular type of dependency binding.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Bind<T1, T2, T3, T4, T5, T6, T7, T8>(params object[] tags);

        /// <summary>
        /// Determines the <see cref="Lifetime"/> of a binding.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().As(Lifetime.Singleton).To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="Pure.DI.Lifetime"/>
        /// <br/><see cref="IConfiguration.DefaultLifetime"/>
        /// </example>
        /// </summary>
        /// <param name="lifetime">The <see cref="Lifetime"/> of a binding</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding As(Pure.DI.Lifetime lifetime);

        /// <summary>
        /// Defines the binding tags.
        /// <example>
        /// Sometimes it's important to take control of building a dependency graph. For example, when there are multiple implementations of the same contract. In this case, tags will help:
        /// <code>
        /// interface IDependency { }
        /// 
        ///
        /// class AbcDependency : IDependency { }
        /// 
        ///
        /// class XyzDependency : IDependency { }
        /// 
        ///
        /// class Dependency : IDependency { }
        /// 
        ///
        /// interface IService
        /// {
        ///     IDependency Dependency1 { get; }
        /// 
        ///
        ///     IDependency Dependency2 { get; }
        /// }
        ///
        /// 
        /// class Service : IService
        /// {
        ///     public Service(
        ///         [Tag("Abc")] IDependency dependency1,
        ///         [Tag("Xyz")] IDependency dependency2)
        ///     {
        ///         Dependency1 = dependency1;
        ///         Dependency2 = dependency2;
        ///     }
        ///
        ///     public IDependency Dependency1 { get; }
        ///
        /// 
        ///     public IDependency Dependency2 { get; }
        /// }
        ///
        /// 
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().Tags("Abc").To&lt;AbcDependency&gt;()
        ///     .Bind&lt;IDependency&gt;().Tags("Xyz").To&lt;XyzDependency&gt;()
        ///     .Bind&lt;IService&gt;().To&lt;Service&gt;().Root&lt;IService&gt;("Root");
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Bind{T}"/>
        /// </example>
        /// </summary>
        /// <param name="tags">The binding tags.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        IBinding Tags(params object[] tags);

        /// <summary>
        /// Completes the binding chain by specifying the implementation.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;();
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Bind{T}"/>
        /// </example>
        /// </summary>
        /// <typeparam name="T">The implementation type. Also supports generic type markers such as <see cref="TT"/>, <see cref="TTList{T}"/>, and others.</typeparam>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration To<T>();

        /// <summary>
        /// Completes the binding chain by specifying the implementation using a factory method. It allows you to manually create an instance, call the necessary methods, initialize properties, fields, etc.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;()
        ///     To(_ =&gt;
        ///     {
        ///         var service = new Service("My Service");
        ///         service.Initialize();
        ///         return service;
        ///     })
        /// </code>
        /// <br/>
        /// another example:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&amp;lt;IService&amp;gt;()
        ///     To(ctx =&amp;gt;
        ///     {
        ///         ctx.Inject&lt;IDependency&gt;(out var dependency);
        ///         return new Service(dependency);
        ///     })
        /// </code>
        /// <br/>
        /// and another example:
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&amp;lt;IService&amp;gt;()
        ///     To(ctx =&amp;gt;
        ///     {
        ///         // Builds up an instance with all necessary dependencies
        ///         ctx.Inject&lt;Service&gt;(out var service);
        ///
        /// 
        ///         service.Initialize();
        ///         return service;
        ///     })
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Bind{T}"/>
        /// </example>
        /// </summary>
        /// <param name="factory">Lambda expression to manually create an instance.</param>
        /// <typeparam name="T">The implementation type.</typeparam>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration To<T>(global::System.Func<IContext, T> factory);
        
        /// <summary>
        /// Completes the binding chain by specifying the implementation using a source code statement.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;int&gt;().To&lt;int&gt;("dependencyId")
        ///     .Bind&lt;Func&lt;int, IDependency&gt;&gt;()
        ///         .To&lt;Func&lt;int, IDependency&gt;&gt;(ctx =&gt;
        ///             dependencyId =&gt;
        ///             {
        ///                 ctx.Inject&lt;Dependency&gt;(out var dependency);
        ///                 return dependency;
        ///             });
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Bind{T}"/>
        /// </example>
        /// </summary>
        /// <param name="sourceCodeStatement">Source code statement</param>
        /// <typeparam name="T">The implementation type.</typeparam>
        /// <returns>Reference to the setup continuation chain.</returns>
        IConfiguration To<T>(string sourceCodeStatement);
    }

    /// <summary>
    /// Abstract injection context./>.
    /// </summary>
    internal interface IContext
    {
        /// <summary>
        /// The tag that was used to inject the current object in the object graph. See also <see cref="IBinding.Tags"/>
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;Lazy&lt;TT&gt;&gt;()
        ///     .To(ctx =&gt;
        ///     {
        ///         ctx.Inject&lt;Func&lt;TT&gt;&gt;(ctx.Tag, out var func);
        ///         return new Lazy&lt;TT&gt;(func, false);
        ///     };
        /// </code>
        /// See also:
        /// <br/><see cref="IConfiguration.Bind{T}"/>
        /// </example>
        /// </summary>
        object Tag { get; }
            
        /// <summary>
        /// Injects an instance of type <c>T</c>.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;()
        ///     To(ctx =&gt;
        ///     {
        ///         ctx.Inject&lt;IDependency&gt;(out var dependency);
        ///         return new Service(dependency);
        ///     })
        /// </code>
        /// <br/>
        /// and another example:<br/>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;()
        ///     To(ctx =&gt;
        ///     {
        ///         // Builds up an instance with all necessary dependencies
        ///         ctx.Inject&lt;Service&gt;(out var service);
        ///
        /// 
        ///         service.Initialize();
        ///         return service;
        ///     })
        /// </code>
        /// See also:
        /// <br/><see cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// </example>
        /// </summary>
        /// <param name="value">Injectable instance.</param>.
        /// <typeparam name="T">Instance type.</typeparam>
        void Inject<T>(out T value);

        /// <summary>
        /// Injects an instance of type <c>T</c> marked with a tag.
        /// <example>
        /// <code>
        /// DI.Setup("Composition")
        ///     .Bind&lt;IService&gt;()
        ///     To(ctx =&gt;
        ///     {
        ///         ctx.Inject&lt;IDependency&gt;("MyTag", out var dependency);
        ///         return new Service(dependency);
        ///     })
        /// </code>
        /// See also:
        /// <br/><see cref="IBinding.To{T}(System.Func{Pure.DI.IContext,T})"/>
        /// </example>
        /// </summary>
        /// <param name="tag">The injection tag. See also <see cref="IBinding.Tags"/></param>.
        /// <param name="value">Injectable instance.</param>.
        /// <typeparam name="T">Instance type.</typeparam>
        void Inject<T>(object tag, out T value);
    }
    
    /// <summary>
    /// An API for a Dependency Injection setup.
    /// <br/>See also:
    /// <br/><see cref="Setup"/>
    /// </summary>
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal static class DI
    {
        /// <summary>
        /// Begins the definitions of the Dependency Injection setup chain.
        /// <example>
        /// <code>
        /// interface IDependency;
        ///
        /// 
        /// class Dependency : IDependency;
        ///
        /// 
        /// interface IService;
        ///
        /// 
        /// class Service(IDependency dependency) : IService;
        ///
        /// 
        /// DI.Setup("Composition")
        ///   .Bind&lt;IDependency&gt;().To&lt;Dependency&gt;()
        ///   .Bind&lt;IService&gt;().To&lt;Service&gt;()
        ///   .Root&lt;IService&gt;("Root");
        /// </code>
        /// </example>
        /// </summary>
        /// <param name="compositionTypeName">An optional argument specifying the partial class name to generate.</param>
        /// <param name="kind">An optional argument specifying the kind of setup. Please <see cref="Pure.DI.CompositionKind"/> for details. It defaults to <c>Public</c>.</param>
        /// <returns>Reference to the setup continuation chain.</returns>
        internal static IConfiguration Setup(string compositionTypeName = "", CompositionKind kind = CompositionKind.Public)
        {
            return Configuration.Shared;
        }

        private sealed class Configuration : IConfiguration
        {
            public static readonly IConfiguration Shared = new Configuration();

            private Configuration() { }
            
            /// <inheritdoc />
            public IBinding Bind(params object[] tags)
            {
                return Binding.Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T>(params object[] tags)
            {
                return Binding.Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2>(params object[] tags)
            {
                return Binding.Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3>(params object[] tags)
            {
                return Binding.Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3, T4>(params object[] tags)
            {
                return Binding.Shared;
            }
            
            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3, T4, T5>(params object[] tags)
            {
                return Binding.Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3, T4, T5, T6>(params object[] tags)
            {
                return Binding.Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3, T4, T5, T6, T7>(params object[] tags)
            {
                return Binding.Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3, T4, T5, T6, T7, T8>(params object[] tags)
            {
                return Binding.Shared;
            }

            /// <inheritdoc />
            public IBinding RootBind<T>(string name = "", RootKinds kind = RootKinds.Default, params object[] tags)
            {
                return Binding.Shared;
            }

            /// <inheritdoc />
            public IConfiguration DependsOn(params string[] setupNames)
            {
                return Configuration.Shared;
            }

            /// <inheritdoc />
            public IConfiguration TypeAttribute<T>(int typeArgumentPosition = 0) where T : global::System.Attribute
            {
                return Configuration.Shared;
            }

            /// <inheritdoc />
            public IConfiguration TagAttribute<T>(int tagArgumentPosition = 0) where T : global::System.Attribute
            {
                return Configuration.Shared;
            }

            /// <inheritdoc />
            public IConfiguration OrdinalAttribute<T>(int ordinalArgumentPosition = 0) where T : global::System.Attribute
            {
                return Configuration.Shared;
            }

            /// <inheritdoc />
            public IConfiguration DefaultLifetime(Pure.DI.Lifetime lifetime)
            {
                return Configuration.Shared;
            }
            
            /// <inheritdoc />
            public IConfiguration Arg<T>(string name, params object[] tags)
            {
                return Configuration.Shared;
            }
            
            /// <inheritdoc />
            public IConfiguration RootArg<T>(string name, params object[] tags)
            {
                return Configuration.Shared;
            }

            /// <inheritdoc />
            public IConfiguration Root<T>(string name, object tag, RootKinds rootKind)
            {
                return Configuration.Shared;
            }

            /// <inheritdoc />
            public IConfiguration Hint(Hint hint, string value)
            {
                return Configuration.Shared;
            }

            /// <inheritdoc />
            public IConfiguration Accumulate<T, TAccumulator>(params Lifetime[] lifetimes)
                where TAccumulator: new()
            {
                return Configuration.Shared;
            }
        }

        private sealed class Binding : IBinding
        {
            public static readonly IBinding Shared = new Binding();

            private Binding() { }
            
            /// <inheritdoc />
            public IBinding Bind(params object[] tags)
            {
                return Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T>(params object[] tags)
            {
                return Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2>(params object[] tags)
            {
                return Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3>(params object[] tags)
            {
                return Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3, T4>(params object[] tags)
            {
                return Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3, T4, T5>(params object[] tags)
            {
                return Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3, T4, T5, T6>(params object[] tags)
            {
                return Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3, T4, T5, T6, T7>(params object[] tags)
            {
                return Shared;
            }

            /// <inheritdoc />
            public IBinding Bind<T1, T2, T3, T4, T5, T6, T7, T8>(params object[] tags)
            {
                return Shared;
            }

            /// <inheritdoc />
            public IBinding As(Pure.DI.Lifetime lifetime)
            {
                return Shared;
            }

            /// <inheritdoc />
            public IBinding Tags(params object[] tags)
            {
                return Shared;
            }

            /// <inheritdoc />
            public IConfiguration To<T>()
            {
                return Configuration.Shared;
            }

            /// <inheritdoc />
            public IConfiguration To<T>(global::System.Func<IContext, T> factory)
            {
                return Configuration.Shared;
            }

            /// <inheritdoc />
            public IConfiguration To<T>(string sourceCodeStatement)
            {
                return Configuration.Shared;
            }
        }
    }
    
    /// <summary>
    /// For internal use.
    /// </summary>
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 1)]
    internal struct Pair<TKey, TValue>
    {
        public readonly TKey Key;
        public readonly TValue Value;

        public Pair(TKey key, TValue value)
        {
            Key = key;
            Value = value;
        }

        public override string ToString()
        {
            return Key?.ToString() ?? "empty" + " = " + Value.ToString();
        }
    }
    
    /// <summary>
    /// For internal use. 
    /// </summary>
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    internal static class Buckets<TKey, TValue>
    {
        public static uint GetDivisor(uint count)
        {
            return count < 2 ? count : count << 1;
        }

        public static Pair<TKey, TValue>[] Create(
            uint divisor,
            out int bucketSize,
            Pair<TKey, TValue>[] pairs)
        {
            bucketSize = 0;
            int[] bucketSizes = new int[divisor];
            for (int i = 0; i < pairs.Length; i++)
            {
                int bucket = (int)(((uint)global::System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(pairs[i].Key)) % divisor);
                int size = bucketSizes[bucket] + 1;
                bucketSizes[bucket] = size;
                if (size > bucketSize)
                {
                    bucketSize = size;
                }
            }
            
            Pair<TKey, TValue>[] buckets = new Pair<TKey, TValue>[divisor * bucketSize];
            for (int i = 0; i < pairs.Length; i++)
            {
                int bucket = (int)(((uint)global::System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(pairs[i].Key)) % divisor);
                var index = bucketSizes[bucket];
                buckets[bucket * bucketSize + bucketSize - index] = pairs[i];
                bucketSizes[bucket] = index - 1;
            }
            
            return buckets;
        }
    }

    /// <summary>
    /// Abstract dependency resolver.
    /// </summary>
    /// <typeparam name="TComposite">The composition type.</typeparam>
    /// <typeparam name="T">The type of the composition root.</typeparam>
    internal interface IResolver<TComposite, out T>
    {
        /// <summary>
        /// Resolves the composition root.
        /// </summary>
        /// <param name="composite">The composition.</param>
        /// <returns>A composition root.</returns>
        T Resolve(TComposite composite);
        
        /// <summary>
        /// Resolves the composition root by type and tag.
        /// </summary>
        /// <param name="composite">The composition.</param>
        /// <param name="tag">The tag of a composition root.</param>
        /// <returns>A composition root.</returns>
        T ResolveByTag(TComposite composite, object tag);
    }
}
#pragma warning restore
#endif
