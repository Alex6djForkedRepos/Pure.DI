// <auto-generated/>
#if !PUREDI_API_SUPPRESSION || PUREDI_API_V2
#pragma warning disable

namespace Pure.DI
{
    internal static class Default
    {
        private static void Setup()
        {
            DI.Setup("", CompositionKind.Global)
                .TypeAttribute<TypeAttribute>()
                .TagAttribute<TagAttribute>()
                .OrdinalAttribute<OrdinalAttribute>()
                .Bind<System.Func<TT>>()
                    .As(Lifetime.PerResolve)
                    .To(ctx => new System.Func<TT>(() =>
                    {
                        TT value;
                        ctx.Inject<TT>(ctx.Tag, out value);
                        return value;
                    }))
                .Bind<global::System.Collections.Generic.IComparer<TT>>()
                .Bind<global::System.Collections.Generic.Comparer<TT>>()
                    .As(Lifetime.PerResolve)
                    .To(_ => global::System.Collections.Generic.Comparer<TT>.Default)
                .Bind<global::System.Collections.Generic.IEqualityComparer<TT>>()
                .Bind<global::System.Collections.Generic.EqualityComparer<TT>>()
                    .As(Lifetime.PerResolve)
                    .To(_ => global::System.Collections.Generic.EqualityComparer<TT>.Default)
#if NETSTANDARD || NET || NETCOREAPP || NET40_OR_GREATER
                .Bind<global::System.Lazy<TT>>()
                    .To(ctx =>
                    {
                        global::System.Func<TT> func;
                        ctx.Inject<global::System.Func<TT>>(ctx.Tag, out func);
                        return new global::System.Lazy<TT>(func, true);
                    })
                .Bind<global::System.Threading.Tasks.Task<TT>>()
                    .To(ctx =>
                    {
                        global::System.Func<TT> func;
                        ctx.Inject<global::System.Func<TT>>(ctx.Tag, out func);
                        return new global::System.Threading.Tasks.Task<TT>(func);
                    })
#endif              
#if NETSTANDARD || NET || NETCOREAPP                
                .Bind<global::System.Lazy<TT, TT1>>()
                    .To(ctx =>
                    {
                        global::System.Func<TT> func;
                        ctx.Inject<global::System.Func<TT>>(ctx.Tag, out func);
                        TT1 metadata;
                        ctx.Inject<TT1>(ctx.Tag, out metadata);
                        return new global::System.Lazy<TT, TT1>(func, metadata, true);
                    })
#endif

                // Collections
#if NETSTANDARD2_1 || NETCOREAPP2_1_OR_GREATER                
                .Bind<global::System.Memory<TT>>()
                    .To(ctx =>
                    {
                        ctx.Inject<TT[]>(out var arr);
                        return new global::System.Memory<TT>(arr);
                    })
                .Bind<global::System.ReadOnlyMemory<TT>>()
                    .As(Lifetime.PerResolve)
                    .To(ctx =>
                    {
                        ctx.Inject<TT[]>(out var arr);
                        return new global::System.ReadOnlyMemory<TT>(arr);
                    })
                .Bind<global::System.Buffers.MemoryPool<TT>>()
                    .To(_ => global::System.Buffers.MemoryPool<TT>.Shared)
                .Bind<global::System.Buffers.ArrayPool<TT>>()
                    .To(_ => global::System.Buffers.ArrayPool<TT>.Shared)
#endif                
                .Bind<global::System.Collections.Generic.ICollection<TT>>()
                .Bind<global::System.Collections.Generic.IList<TT>>()
                .Bind<global::System.Collections.Generic.List<TT>>()
                    .To(ctx =>
                    {
                        ctx.Inject<TT[]>(out var arr);
                        return new global::System.Collections.Generic.List<TT>(arr);
                    })
#if NETSTANDARD || NET || NETCOREAPP || NET45_OR_GREATER                
                .Bind<global::System.Collections.Generic.IReadOnlyCollection<TT>>()
                .Bind<global::System.Collections.Generic.IReadOnlyList<TT>>()
                    .As(Lifetime.PerResolve)
                    .To(ctx =>
                    {
                        ctx.Inject<TT[]>(out var arr);
                        return arr;
                    })
#endif
#if NETSTANDARD || NET || NETCOREAPP || NET40_OR_GREATER
                .Bind<global::System.Collections.Generic.ISet<TT>>()
#endif
#if NETSTANDARD || NET || NETCOREAPP || NET35_OR_GREATER
                .Bind<global::System.Collections.Generic.HashSet<TT>>()
                    .To(ctx =>
                    {
                        ctx.Inject<TT[]>(out var arr);
                        return new global::System.Collections.Generic.HashSet<TT>(arr);
                    })
#endif
#if NETSTANDARD || NET || NETCOREAPP || NET45_OR_GREATER
                .Bind<global::System.Collections.Generic.SortedSet<TT>>()
                    .To(ctx =>
                    {
                        ctx.Inject<TT[]>(out var arr);
                        return new global::System.Collections.Generic.SortedSet<TT>(arr);
                    })
#endif                
                .Bind<global::System.Collections.Generic.Queue<TT>>()
                    .To(ctx =>
                    {
                        ctx.Inject<TT[]>(out var arr);
                        return new global::System.Collections.Generic.Queue<TT>(arr);
                    })
                .Bind<global::System.Collections.Generic.Stack<TT>>()
                    .To(ctx =>
                    {
                        ctx.Inject<TT[]>(out var arr);
                        return new global::System.Collections.Generic.Stack<TT>(arr);
                    })
#if NET || NETCOREAPP
                .Bind<global::System.Collections.Immutable.ImmutableArray<TT>>()
                    .As(Lifetime.PerResolve)
                    .To(ctx =>
                    {
                        TT[] arr;
                        ctx.Inject<TT[]>(out arr);
                        return global::System.Runtime.CompilerServices.Unsafe.As<TT[], global::System.Collections.Immutable.ImmutableArray<TT>>(ref arr);
                    })
                .Bind<global::System.Collections.Immutable.IImmutableList<TT>>()
                .Bind<global::System.Collections.Immutable.ImmutableList<TT>>()
                    .As(Lifetime.PerResolve)
                    .To(ctx =>
                    {
                        TT[] arr;
                        ctx.Inject<TT[]>(out arr);
                        return global::System.Runtime.CompilerServices.Unsafe.As<TT[], global::System.Collections.Immutable.ImmutableList<TT>>(ref arr);
                    })
                .Bind<global::System.Collections.Immutable.IImmutableSet<TT>>()
                .Bind<global::System.Collections.Immutable.ImmutableHashSet<TT>>()
                    .As(Lifetime.PerResolve)
                    .To(ctx =>
                    {
                        TT[] arr;
                        ctx.Inject<TT[]>(out arr);
                        return global::System.Runtime.CompilerServices.Unsafe.As<TT[], global::System.Collections.Immutable.ImmutableHashSet<TT>>(ref arr);
                    })
                .Bind<global::System.Collections.Immutable.ImmutableSortedSet<TT>>()
                    .As(Lifetime.PerResolve)
                    .To(ctx =>
                    {
                        TT[] arr;
                        ctx.Inject<TT[]>(out arr);
                        return global::System.Runtime.CompilerServices.Unsafe.As<TT[], global::System.Collections.Immutable.ImmutableSortedSet<TT>>(ref arr);
                    })
                .Bind<global::System.Collections.Immutable.IImmutableQueue<TT>>()
                .Bind<global::System.Collections.Immutable.ImmutableQueue<TT>>()
                    .As(Lifetime.PerResolve)
                    .To(ctx =>
                    {
                        TT[] arr;
                        ctx.Inject<TT[]>(out arr);
                        return global::System.Runtime.CompilerServices.Unsafe.As<TT[], global::System.Collections.Immutable.ImmutableQueue<TT>>(ref arr);
                    })
                .Bind<global::System.Collections.Immutable.IImmutableStack<TT>>()
                .Bind<global::System.Collections.Immutable.ImmutableStack<TT>>()
                    .As(Lifetime.PerResolve)
                    .To(ctx =>
                    {
                        TT[] arr;
                        ctx.Inject<TT[]>(out arr);
                        return global::System.Runtime.CompilerServices.Unsafe.As<TT[], global::System.Collections.Immutable.ImmutableStack<TT>>(ref arr);
                    })
#endif
                    ;
        }
    }
}
#pragma warning restore
#endif